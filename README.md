# Physical-Design-with-OpenLANE-using-Sky130-PDK
This project was completed for the VLSI System Design Corporation's "Advanced Physical Design using OpenLANE/Sky130" course. This project uses Skywater 130nm PDK and Openlane to run an entire RTL to GDSII sequence for the PicoRV32a SoC. Additionally employed in the flow are standard cells with a custom design and Sky130 PDK. There are timing optimisations made. Violations of slack are eliminated. DRC is confirmed.
# Inside a chip:
The chip is connected to the outside world by pads, and different signals are used to access the chip from there.
The ASIC's digital logic is located at the core.
The Die determines the IC's packaging or skeleton size.
The typical IC would include a SoC, SRAM, PLLs (to double or divide the main clock frequency), ADC and DAC blocks to enable analogue communication with the outside world, as well as a few more blocks. Foundry IPs, or "Foundry intellectual property," are the blocks.

The foundries are where the chips are made, and their research gives us the PDKs that are used to design the ICs. Since the research is expensive and The Foundry IPs are confidential,although there are open source PDKs like Skywater130, which is a 130nm process node, meaning the channel length between the source and drain is 130nm, the PDKs are extremely secret. There are ICs with a 5nm manufacturing node currently available.
Macro, such as the SoC depicted in the diagram, is fully digital logic that is built using a Hardware Description language.

Even for embedded designs, communication with the foundry is crucial because a different process node for a SoC with the same functionality could result in signal integrity problems for a PCB because the rise time for different SoCs manufactured with different process nodes would be different. As a result, the already tested and functional PCB with the SoC manufactured with a 130nm process node would experience these issues.

![Untitled](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/73e010e3-e5d4-4503-aea3-46605c252713)
![Untitled 2](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/1334bc54-9cc6-4d5c-b8bf-4e7b5bd940b9)

#Instruction Set Architecture (ISA)
The interface between a computer system's hardware and software is defined by a collection of guidelines and specifications called the Instruction collection Architecture (ISA). It establishes how a processor interprets and carries out instructions given by software applications. As long as they follow the instructions and rules specified by the ISA, it enables software developers to design programmes without worrying about the specifics of the underlying hardware.

Humans write a piece of code in a comprehensible language, which is then translated into Assembly code in accordance with an ISA. The assembly code is written in hexadecimal digits, which are then translated into binary numbers or the on/off of transistors laid out in a certain way that can run on the specific ISA for which the layout is intended. The bits enter the layout, and the output is produced.

RISC-V ISA is used as an illustration. An HDL language is used to design the ISA's layout, and an RTL description follows. The RISC-V architecture specifications are implemented in the RTL description, and an IC that can execute human-written code is created by following the RTL to GDSII path.

![Untitled 4](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/17a8be77-44eb-49f8-9e64-4ae03cb6310e)

# Hardware and Software Symbiosis
The system software, which consists of the operating system, compiler, and assembler, is used to read the application software. The application software is transformed into hardware-compatible binary code by the system software.

The OS compiles and translates the application programme into assembly code. Apart from memory allocation, processing IO operations, and low-level system tasks like memory management, process management, user interface, task scheduling, power management, error handling and logging, file system administration, networking, etc., this is the OS's primary job.
Small functions written in one of the languages, such as C, C++, Java, VB, etc., are the outputs of an OS. The assembly language code is then generated by compiling these short routines. The Hardware designed, for example, affects the syntax of the assembly code. Different assembly code syntaxes apply to RISC-V and Intel x86 devices, respectively. This syntax is known as ISA. The machine language, or binary language, that is provided to the hardware is converted by the assembler. The device outputs data in accordance with the pattern of the received binary digits.
![Untitled 6](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/151cfe45-c368-4f62-b059-6587d2efe19c)
![Untitled 7](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/79ace2e2-6cff-473a-81fd-8f715aa53939)

# SOC Design and Openlane 

## Components of opensource digital ASIC design
Three enablers or pieces are needed to create a digital Application Specific Integrated Circuit (ASIC): Process create Kit (PDK) data, Electronic Design Automation (EDA) tools, and Resistor Transistor Logic Intellectual Property (RTL IPs).
![124005001-35a32a80-d9f6-11eb-8fcc-0917ad337699](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/a885ba9b-f9a8-4f32-9c05-3dbf48a2f444)
 1. Opensource RTL Designs: github, librecores, opencores
 2. Opensource EDA tools: QFlow, OpenROAD, OpenLANE
 3. Opensource PDK data: Google Skywater130 PDK
### Simplified RTL2GDS Flow

![124006238-a139c780-d9f7-11eb-8da9-6069b055fbe0](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/899ccdf7-663d-4103-bab6-0abfedb9674a)

![131134578-5cd34ec9-a388-476b-aa4b-914c250d7ec9](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/466e980b-2eea-4012-8598-10c964860d52)

1. Synthesis: RTL Converted to gate level netlist using standard cell libraries (SCL).
2. Floor & Power Planning: Planning of silicon area to ensure robust power distribution.
3. Placement: Placing cells on floorplan rows aligned with sites.
4. Global Placement: for optimal position of cells.
5. Detailed Placement: for legal positions.
6. Routing: Valid patterns for wires.
7. Signoff: Physical (DRC, LVS) and Timing verifications (STA).

#### Openlane asic flow

![185787620-8c999b89-2580-477d-aa20-1156d3e996c8](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/68a2dab8-a55b-46cb-9bb1-9574f7134cbc)

![131135115-46148ff1-9489-48f6-a334-6702c25def59](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/e38635b0-bd7b-4301-8e07-1f85715a7bfe)

From conception to product, the ASIC design flow is an iterative process that is not static for every design. The details of the flow may change depending on ECO’s, IP requirements, DFT insertion, and SDC constraints, however the base concepts still remain. The flow can be broken down into 11 steps:

Architectural Design – A system engineer will provide the VLSI engineer with specifications for the system that are determined through physical constraints. The VLSI engineer will be required to design a circuit that meets these constraints at a microarchitecture modeling level.

RTL Design/Behavioral Modeling – RTL design and behavioral modeling are performed with a hardware description language (HDL). EDA tools will use the HDL to perform mapping of higher-level components to the transistor level needed for physical implementation. HDL modeling is normally performed using either Verilog or VHDL. One of two design methods may be employed while creating the HDL of a microarchitecture:

a. RTL Design – Stands for Register Transfer Level. It provides an abstraction of the digital circuit using:

i. Combinational logic
ii. Registers
iii. Modules (IP’s or Soft Macros)
b. Behavioral Modeling – Allows the microarchitecture modeling to be performed with behavior-based modeling in HDL. This method bridges the gap between C and HDL allowing HDL design to be performed

RTL Verification - Behavioral verification of design

DFT Insertion - Design-for-Test Circuit Insertion

Logic Synthesis – Logic synthesis uses the RTL netlist to perform HDL technology mapping. The synthesis process is normally performed in two major steps:

GTECH Mapping – Consists of mapping the HDL netlist to generic gates what are used to perform logical optimization based on AIGERs and other topologies created from the generic mapped netlist.

Technology Mapping – Consists of mapping the post-optimized GTECH netlist to standard cells described in the PDK

Standard Cells – Standard cells are fixed height and a multiple of unit size width. This width is an integer multiple of the SITE size or the PR boundary. Each standard cell comes with SPICE, HDL, liberty, layout (detailed and abstract) files used by different tools at different stages in the RTL2GDS flow.

Post-Synthesis STA Analysis: Performs setup analysis on different path groups.

Floorplanning – Goal is to plan the silicon area and create a robust power distribution network (PDN) to power each of the individual components of the synthesized netlist. In addition, macro placement and blockages must be defined before placement occurs to ensure a legalized GDS file. In power planning we create the ring which is connected to the pads which brings power around the edges of the chip. We also include power straps to bring power to the middle of the chip using higher metal layers which reduces IR drop and electro-migration problem.

Placement – Place the standard cells on the floorplane rows, aligned with sites defined in the technology lef file. Placement is done in two steps: Global and Detailed. In Global placement tries to find optimal position for all cells but they may be overlapping and not aligned to rows, detailed placement takes the global placement and legalizes all of the placements trying to adhere to what the global placement wants.

CTS – Clock tree synteshsis is used to create the clock distribution network that is used to deliver the clock to all sequential elements. The main goal is to create a network with minimal skew across the chip. H-trees are a common network topology that is used to achieve this goal.

Routing – Implements the interconnect system between standard cells using the remaining available metal layers after CTS and PDN generation. The routing is performed on routing grids to ensure minimal DRC errors.

The Skywater 130nm PDK uses 6 metal layers to perform CTS, PDN generation, and interconnect routing.

Opensource EDA tools
OpenLANE utilises a variety of opensource tools in the execution of the ASIC flow:

Task	Tool/s
RTL Synthesis & Technology Mapping	yosys, abc
Floorplan & PDN	init_fp, ioPlacer, pdn and tapcell
Placement	RePLace, Resizer, OpenPhySyn & OpenDP
Static Timing Analysis	OpenSTA
Clock Tree Synthesis	TritonCTS
Routing	FastRoute and TritonRoute
SPEF Extraction	SPEF-Extractor
DRC Checks, GDSII Streaming out	Magic, Klayout
LVS check	Netgen
Circuit validity checker	CVC
OpenLANE design stages
Synthesis
yosys - Performs RTL synthesis
abc - Performs technology mapping
OpenSTA - Performs static timing analysis on the resulting netlist to generate timing reports
Floorplan and PDN
init_fp - Defines the core area for the macro as well as the rows (used for placement) and the tracks (used for routing)
ioplacer - Places the macro input and output ports
pdn - Generates the power distribution network
tapcell - Inserts welltap and decap cells in the floorplan
Placement
RePLace - Performs global placement
Resizer - Performs optional optimizations on the design
OpenDP - Perfroms detailed placement to legalize the globally placed components
CTS
TritonCTS - Synthesizes the clock distribution network (the clock tree)
Routing
FastRoute - Performs global routing to generate a guide file for the detailed router
CU-GR - Another option for performing global routing.
TritonRoute - Performs detailed routing
SPEF-Extractor - Performs SPEF extraction
GDSII Generation
Magic - Streams out the final GDSII layout file from the routed def
Klayout - Streams out the final GDSII layout file from the routed def as a back-up
Checks
Magic - Performs DRC Checks & Antenna Checks
Klayout - Performs DRC Checks
Netgen - Performs LVS Checks
CVC - Performs Circuit Validity Checks
OpenLANE Files
The openLANE file structure looks something like this:

skywater-pdk: contains PDK files provided by foundry
open_pdks: contains scripts to setup pdks for opensource tools
sky130A: contains sky130 pdk files


# Labs
## 1. Initiating Openlane, Design setup stage and synthesis

1. Go to the OpenLane directory using “ cd ” command.
2. Initiate Docker using : docker
3. To strat the openlane : ./flow.tcl -interactive
 
![Untitled 1](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/bb40f722-006c-495c-a2f3-8fc1f8a52f3f)

4. For the packages to be installed we use : package require openlane 0.9

The Picorv32a design is investigated in this case. The source files are already provided in the designs folder, and the design has already been adjusted for the best results. At least three files, src, config.tcl, and sky130A_sky130_fd_sc_hd_config.tcl, are present in the folder.

The verilog files and SDC "Synopsys Design Constraint" file are both located in the src folder. Almost all Synthesis, PnR, and other tools support SDC, a common format for design constraints.

The default settings made by openlane can be changed or overridden by editing the config.tcl file.

sky130A_sky130_fd_sc_hd can be interpreted as (pdk variation)_(pdk)_(foundry)_(standard cell)_(high density). There can be other variations of PDK with acronyms: hdll - ms - ls - hs -
sky130A_sky130_fd_sc_hd_config.tcl file contains another design tweaks that can be done to modify the design.

The priority order is sky130A_sky130_fd_sc_hd_config.tcl > config.tcl > Default configurations.

How to decide priority in:

sky130A_sky130_fd_sc_hd_config.tcl
sky130A_sky130_fd_sc_hdll_config.tcl
sky130A_sky130_fd_sc_ms_config.tcl
sky130A_sky130_fd_sc_ls_config.tcl
sky130A_sky130_fd_sc_hs_config.tcl

### Designing the setup stage
We must set up a file system that is tailored to the flow. The design preparation stage creates the locations needed for the files to be fetched at each phase of the flow. The following command is used:   prep -design picorv32a

The "prep" command is used to create the basic environment, input files, and configurations needed for the succeeding OpenLane flow phases.

The "-design" option or flag is used in conjunction with the "prep" command to define the design that needs to be created. The name of the provided design in this instance is "picorv32a". It means that the environment will be particularly set up for the "picorv32a" design by using the "prep" command.

In this phase, the LEF files at the cell level and the technology level are combined into a single file so that the openlane flow does not need to access several files to obtain data on cell geometry, layers, etc. Cell level LEF defines the physical and electrical characteristics of each individual standard cell inside a given library or cell set, whereas technology level LEF describes the general process technology features. One file called merged.lef is created by merging these two LEF files.

Its initials stand for "Library Exchange Format." The physical and electrical characteristics of library cells or standard cells are described in LEF files. Within the electrical design automation (EDA) toolchain, these files provide crucial information for the physical design stages, such as location and routing.

Cell Geometries: Specifies the dimensions of standard cells, such as their height, breadth, and layer.
The pins and ports connected to each cell are referred to as pins and ports. For metal connections, these definitions provide details about name, direction (input or output), and layer.
Describe the various layers that were employed in the design, such as the diffusion, polysilicon, and metal layers. The name, type, direction, and other attributes of each layer are defined, enabling the physical design tools to comprehend the layers that are accessible for routing and manufacturing.
Information on the site, which is the area or grid that a cell is placed in, as well as its symmetry. To describe the symmetrical characteristics of the cells, they might contain symmetry information. Electrical Information: Capacitance is one of the electrical properties of cells.

![picking up the files](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/e7fa7588-cf04-40c5-8bd9-1dedd064e9a0)


The “ results ” folder will have files generated when different steps such as floor planning, CTS, synthesis etc are performed. Similiarly for reports folder.

This file again has config.tcl shows what parameters have been modified. With every step performed there will be a config.tcl file generated, which will inform about what changes have been made.

![folder is created](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/8c29352d-1796-42a7-8815-9fc3dbaf2ae4)

We can see the results of all folders that are created

![there are separate results for each of them](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/8b295aa3-2a92-43fd-9953-1aa836bc4a53)

The merged.lef file can be accessed in the tmp folder, by using the command:  less merged.lef
to exit we use q 

## Synthesis 

The yosys and ABC tools are utilized to convert RTL to gate level netlist. After the design setup is ready, To run the synthesis and generate gate-level netlist by command: run_synthesis

In the report generated by synthesis, we are interested in chip module area and Flop ratio as of now:

Flop ratio = no. of D-flip flops used/no. of cells used.

here, flop ratio = 1613/14876 = 0.1084

The statistics report of the synthesis is generated in the reports folder in the synthesis directory, and it is accessed using “less” command. The file is named “yosys_4.stat.rpt”

![no of d flipflops](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/e21dba3f-b0e2-4d59-a817-67705a167b71)

The synthesis was succesful

![synthesis successful](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/c5383790-9c31-430e-86bd-f9324d8cb9a3)

## 2. Floorplanning and placement

We are interested in two parameters as of now, Utilisation Factor and Aspect Ratio. They are defined as follows:

Utilisation Factor =  Area occupied by netlist/Total area of core

Aspect Ratio =  Height/ Width
              

A Utilization Factor of 1 signifies 100% utilization leaving no space for extra cells such as buffer. However, practically, the Utilisation Factor is 0.5-0.6. Likewise, an Aspect ratio of 1 implies that the chip is square shaped. Any value other than 1 implies rectangular chip.

Priority order of configuration files to be used by the Openlane flow:

sky130A_sky130_fd_sc_hd_config.tcl

conifg.tcl

floorplan.tcl - System default variables.

The variables we are interested in as of now:

Floorplan environment variables or switches:

FP_CORE_UTIL - floorplan core utilization
FP_ASPECT_RATIO - floorplan aspect ratio
FP_CORE_MARGIN - Core to die margin area
FP_IO_MODE - defines pin configurations (1 = equidistant/0 = not equidistant)
FP_CORE_VMETAL - vertical metal layer
FP_CORE_HMETAL - horizontal metal layer
Note: Vertical metal layer and Horizontal metal layer values will be 1 more than that specified in the files.

After setting the desired variables, to run the picorv32a floorplan in openLANE:

run_floorplan

A.def file will have been produced in the results/floorplan directory following the floorplan run. The switches set in conifg.tcl and sky130A_sky130_fd_sc_hd_config.tcl will have overridden the system defaults, respectively. Using the magic tool, we can examine floorplan files.

Decoupling capacitors: 
Pre-placed cells must then be surrounded with decoupling capacitors (decaps). The resistances and capacitances associated with long wire lengths can cause the power supply voltage to drop significantly before reaching the logic circuits. This can lead to the signal value entering into the undefined region, outside the noise margin range. Decaps are huge capacitors charged to power supply voltage and placed close the logic circuit. Their role is to decouple the circuit from power supply by supplying the necessary amount of current to the circuit. They pervent crosstalk and enable local communication.


![applying decoupling capacitors](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/46f74740-9544-4301-bce6-4c9d8b93d23f)



After navigating to the results/floorplan directory, where the floorplan's.def file is generated, Magic is used to examine the floorplan. It is necessary to specify the location of the PDK's tech lef file, which can be found in the /openlane_working_dir/pdks/sky130A/libs.tech/magic folder. It's vital to note that the command also includes the name of the.tech file; otherwise, the tool won't be able to locate it. The command's syntax is as follows:

magic -T <path to .tech file> read lef <path to .lef file> read def <path to .def file>
 
 The Command is :
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &
 
  ![Untitled 6 (1)](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/4aaa43f1-5c4b-4b67-8e73-c46014a6b3b2)

![4 florr planning and showing what is what cell](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/3387077f-a87b-4a1c-82fc-86bde6ea6ceb)

### Placement
 
 Placement is the following stage in the OpenLANE ASIC flow. The floorplan will then be populated with the synthesised netlist. Placement is done in two steps:

Global Positioning: It determines the best position for every cell, even if it may not be legal or if some cells may overlap. Optimisation is carried out by cutting the parameter wire length in half.
Detailed Placement: It moves cells after global placement to make them legal.

#### Placement run on OpenLANE & view in Magic
 The objective of placement is the convergence of overflow value. If overflow value reduces during the placement run it means that the design will converge and placement will be successful. The design can be viewed on magic within results/placement directory:
The command used is : run_floorplan  the magic T used is 
 
magic -T /home/aastha/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
 
 ![8](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/ab80dc6a-197c-4552-9b34-d0560c1bbb39)
 
 
 ![9 standard cellplacements](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/1f66d873-c68e-48b5-bec7-fb117eaaefd9)
 
 ### Standard cell design flow
 Standard cell design flow steps are:

1. Inputs: PDKs, DRC & LVS rules, SPICE models, libraries, user-defined specifications
2. Design steps: Circuit design, Layout design, Extraction of parasitics, Characterization (timing, noise, power)
3. Outputs: CDL (circuit description language), LEF, GDSII, extracted SPICE netlist (.cir), timing, noise and power .lib files

### Standard Cell Characterization Flow
 A typical standard cell characterization flow includes the following steps:

1. Read in the models and tech files
2. Read extracted spice netlist
3. Recognize behavior of the cell
4. Read the subcircuits
5. Attach power sources
6. Apply stimulus to characterization setup
7. Give necessary output capacitance loads
8. Give necessary simulation commands
 
### Timing Parameters
 |slew_low_rise_thr  | 20% value |
 |      :---:        |  :----:   |
 |slew_high_rise_thr | 80% value |
 |slew_low_fall_thr  | 20% value |
 |slew_high_falle_thr| 80% value |
 |in_rise_thr        | 50% value |
 |in_fall_thr        | 50% value |
 |out_rise_thr       | 50% value |
 |out_fall_thr       | 50% value |
 
rise delay =  time(out_fall_thr) - time(in_rise_thr)

Fall transition time: time(slew_high_fall_thr) - time(slew_low_fall_thr)

Rise transition time: time(slew_high_rise_thr) - time(slew_low_rise_thr)
 
## Design Library Cell
 
Users of OpenLANE can instantly modify environment variables. For instance, in the openLANE flow, we could do the following if we wanted to switch the pin location from equidistant to another style of placement:
 
set ::env(FP_IO_MODE) 2
 
## SPICE Deck creation & Simulation

 A SPICE deck includes information about the following:

1. Model description
2. Netlist description
3. Component connectivity
4. Component values
5. Capacitance load
6. Nodes
7. Simulation type and parameters
8. Libraries included
 
 ## 16 Mask CMOS Fabrication 
 
1. Selection of subtrate: Secting the body/substrate material.
2. Creating active region for transistors: Isolation between active region pockets by SiO2 and Si3N4 deposition followed by photolithography and etching.
3. N-well and P-well formation: Ion implanation by Boron for P-well and by Phosphorous for N-well formation.
4. Formation of gate terminal: NMOS and PMOS gates formed by photolithography techniques.
5. LDD (lightly doped drain) formation: LDD formed to prevent hot electron effect.
6. Source & drain formation: Screen oxide added to avoid channelling during implants followed by Aresenic implantation and annealing.
7. Local interconnect formation: Removal of screen oxide by HF etching. Deposition of Ti for low resistant contacts.
8. Higher level metal formation: CMP for planarization followed by TiN and Tungsten deposition. Top SiN layer for chip protection.
 
  ![Schematic-representation-of-a-CMOS-fabrication-process-with-SiGe-MBE](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/3fcb653b-b552-460e-9413-4b10b3a4ca8f)
 
## Inverter Standard cell Layout & SPICE extraction
 
To integrate the CMOS inverter with the picorv32a design, the Magic layout of an inverter will be employed. This is accomplished by cloning the inverter magic file from vsdstdcelldesign and placing it in the openlane_working_dir/openlane directory as shown below:
 
 git clone https://github.com/nickson-jose/vsdstdcelldesign
 
This creates a vsdstdcelldesign named folder in the openlane directory.

To invoke magic to view the sky130_inv.mag file, the sky130A.tech file must be included in the command along with its path. To ease up the complexity of this command, the tech file can be copied from the magic folder to the vsdstdcelldesign folder.
 
 magic -T sky130A.tech sky130_inv.mag &
 
 
![7 itshows the n and p diff regions](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/d5bee43e-ed24-4990-8287-a643f0a450b0)

 
 ![4 mac cmos layout](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/54970f50-10a7-412c-9db4-648772fdabd2)
 
The local interconnect layer, or Locali, is the top layer of Sky130.

Verification of P-diffusion and N-diffusion areas with Polysilicon can be seen to see if the architecture is that of a CMOS inverter.

Checking the connections between the drain and source is another verification step. Both PMOS and NMOS must have their sources and drains connected to the power supply VDD (in this case, VPWR) and output port, respectively.

The LEF, or library exchange format, provides information about cell boundaries, VDD lines, and GND lines. It is used to safeguard the IP but does not carry any information about the circuit logic.

The following commands are used in tkcon within the Magic environment to achieve.mag to.spice extraction:
 
extract all
ext2spice cthresh 0 rethresh 0
ext2spice
 
  ![185789439-e7a512a3-e4d7-467f-9baf-0f03fcb990dd (1)](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/ba8f1244-132a-49a9-bced-916d148d9c2d)

 
This generates the sky130_in.spice file. This SPICE deck is updated to include pshort.lib and nshort.lib which are the PMOS and NMOS libraries respectively. In addition, the minimum grid size of inverter is measured from the magic layout and incorporated into the deck as: .option scale=0.01u. The MOSFET definitions' model names have been modified to pshort.model.0 and nshort.model.0 for PMOS and NMOS, respectively.
 
The commands are given 
 
For simulation, ngspice is invoked in the terminal:

ngspice sky130_inv.spice
The output "y" is to be plotted with "time" and swept over the input "a":

plot y vs time a

![185789474-f6f9ab3c-adcc-48d9-a988-8b5ff5bc7f49](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/1f50f1ce-c384-4db1-a13f-4e31f8d3c66c)

 The waveforms are as shown
 
 
 ![185789476-9b49eb13-8a60-4166-a4f6-5acf58178c3b](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/351834c9-2258-447c-9c91-f2b82962aa30)
 
 
 ![185789489-1cc709cb-395b-4db7-894c-e90cbe8553c5](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/d90257d5-46bc-40cc-b543-c8845e952ef4)

The spikes in the output at switching points is due to low capacitance loads. This can be taken care of by editing the spice deck to increase the load capacitance value.
 
### Standard cell characterization of inverter
 
 Four timing parameters are used to characterize the inverter standard cell:

1. Rise transition: Time taken for the output to rise from 20% of max value to 80% of max value
2. Fall transition- Time taken for the output to fall from 80% of max value to 20% of max value
3. Cell rise delay = time(50% output rise) - time(50% input fall)
4. Cell fall delay = time(50% output fall) - time(50% input rise)
5. The above timing parameters can be computed by noting down various values from the ngspice waveform.

Rise transition = (2.23843 - 2.17935) = 59.08ps
Fall transition = (4.09291 - 4.05004) = 42.87ps
Cell rise delay = (2.20636 - 2.15) = 56.36ps
Cell fall delay = (4.07479 - 4.05) = 24.79ps
 
### Timing analysis and CTS
 
According to tracks.info, ports must be located at the intersection of horizontal and vertical rails. The li1 layer contains the CMOS Inverter ports A and Y. Make sure they are at the point where the horizontal and vertical tracks meet. For the pitch and direction data, we access the tracks.info file:

 To ensure that ports lie on the intersection point, the grid spacing in Magic (tkcon) must be changed to the li1 X and li1 Y values. Convergence of grid and tracks can be achieved using the following command:

grid 0.46um 0.34um 0.23um 0.17um
 

 ![185789878-18b441ec-af32-4f3f-b123-2908b864c6fb](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/5ee954d0-efab-4d7a-8a6b-d93c2a859bf5)

#### Creating port definition
 
Extraction of the LEF file for the cell comes next when the layout is completed. To help the placer and router tool, specific characteristics and definitions must be defined for the cell's pins. Ports are the macro's declared PINs, and in LEF files, a cell containing ports is written as a macro cell. Our goal is to extract LEF in a predetermined format from a configuration (in this case, a straightforward CMOS inverter). The first step is to define each port and assign the appropriate class and use characteristics to each port.
 
The easiest way to define a port is through Magic Layout window and following are the steps:

1. In Magic Layout window, first source the .mag file for the design (here inverter). Then Edit >> Text which opens up a dialogue box.
 
 
 ![185789881-929deae7-d4eb-4842-9829-13a286be397a (2)](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/a694236a-6e78-4fe0-9c14-4e40aca25153)
 
2. Create a box on the layer that will hold each layer that will become a port, then enter a label name and a sticky label containing the name of the layer that the port should be connected to. As shown in the image, make sure the Port enable option is selected and the default checkbox is not selected.
 
 ![185789884-8da9ac43-e273-4c94-9f68-2edbf77fcded (1)](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/6aba9283-3c64-4cd0-af4e-6295a29e2ffb)
 
In the above two figures, port A (input port) and port Y (output port) are taken from locali (local interconnect) layer. Also, the number in the textarea near enable checkbox defines the order in which the ports will be written in LEF file (0 being the first).

3. For power and ground layers, the definition could be same or different than the signal layer. Here, ground and power connectivity are taken from metal1 (Notice the sticky label).
 

 ![185789892-7cf30d76-b01b-4a42-8b05-0c2e8c772d04](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/78cbe141-b4f1-48a8-aecb-d90210da0d19)

 
###  Standard generation of LEF
 
 Before the CMOS Inverter standard cell LEF is extracted, the purpose of ports must be defined:

Select port A in magic:

port class input
port use signal
Select Y area

port class output
port class signal
Select VPWR area

port class inout
port use power
Select VGND area

port class inout
port use ground
LEF extraction can be carried out in tkcon as follows:

lef write
 
 
 ![185790311-f5a68ba1-9e1d-47b1-ae47-d7a6f1a723d2 (1)](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/c9bc5008-51b4-4dc9-a1fc-cc50490d9b16)
 
This generates sky130_vsdinv.lef file.

Integrating custom cell in OpenLANE
In order to include the new standard cell in the synthesis, copy the sky130_vsdinv.lef file to the designs/picorv32a/src directory
Since abc maps the standard cell to a library abc there must be a library that defines the CMOS inverter. The sky130_fd_sc_hd_typical.lib file from vsdstdcelldesign/libs directory needs to be copied to the designs/picorv32a/src directory (Note: the slow and fast library files may also be copied).

Next, config.tcl must be modified:

set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130/sky130_fd_sc_hd__typical.lib"
set ::env(LIB_SLOWEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130/sky130_fd_sc_hd__slow.lib"
set ::env(LIB_FASTEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]
modified config.tcl file:


 # User config
set ::env(DESIGN_NAME) "picorv32a"

# Change if needed
set ::env(VERILOG_FILES) "./designs/picorv32a/src/picorv32a.v"
set ::env(SDC_FILES) "./designs/picorv32a/src/picorv32a.sdc"


# turn off clock
set ::env(CLOCK_PERIOD) "5.000"
set ::env(CLOCK_PORT) "clk"

set ::env(CLOCK_MET) $::env(CLOCK_PORT) 


set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib "
set ::env(LIB_MIN) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_MAX) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib "
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]

set filename $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/$::env(PDK)_$::env(STD_CELL_LIBRARY)_config.tcl
#set filename $::env(DESIGN_DIR)/$::env(PDK)_$::env(STD_CELL_LIBRARY)_config.tcl
if { [file exists $filename] == 1 } {
      source $filename
}

 In order to integrate the standard cell in the OpenLANE flow, invoke openLANE as usual and carry out following steps:

prep -design picorv32a -tag RUN_2022.08.17_16.22.21 -overwrite
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
run_synthesis
 
Next floorplan is run, followed by placement:

run_floorplan
run_placement
To check the layout invoke magic from the results/placement directory:

magic -T /home/devipriya/OpenLane/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.max.lef d
 
 
 ![185794679-cd0de4df-30a6-46bd-b6dd-c73a727d85f4](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/f9396121-aa56-4f38-b977-eba7fcadd2aa)

 
## After synthesis analysis
 
 Using the OpenSTA tool, timing analysis is done outside of the openLANE flow. A new file called pre_sta.conf is made just for this. The STA analysis would require the use of this file. Outside of the openLANE flow, invoke OpenSTA as follows:

pre_sta.conf for sta
The study is with respect to ideal clocks and only setup time slack is taken into account because clock tree synthesis has not yet been done. The discrepancy between data arrival time and data necessary time is the slack value. It is required that the worst slack value be more than or equal to one. The steps that can be taken if a negative slack is acquired are as follows:

1. Change the values for the synthesis approach, synthesis buffering, and synthesis sizing.
2. Review the cells' maximum fanout and replace those with a high fanout
 
 The file generated with the following commands:
 
 VERSION 5.7 ;
  NOWIREEXTENSIONATPIN ON ;
  DIVIDERCHAR "/" ;
  BUSBITCHARS "[]" ;
MACRO sky130_vsdinv
  CLASS CORE ;
  FOREIGN sky130_vsdinv ;
  ORIGIN 0.000 0.000 ;
  SIZE 1.380 BY 2.720 ;
  SITE unithd ;
  PIN A
    DIRECTION INPUT ;
    USE SIGNAL ;
    ANTENNAGATEAREA 0.165600 ;
    PORT
      LAYER li1 ;
        RECT 0.060 1.180 0.510 1.690 ;
    END
  END A
  PIN Y
    DIRECTION OUTPUT ;
    USE SIGNAL ;
    ANTENNADIFFAREA 0.287800 ;
    PORT
      LAYER li1 ;
        RECT 0.760 1.960 1.100 2.330 ;
        RECT 0.880 1.690 1.050 1.960 ;
        RECT 0.880 1.180 1.330 1.690 ;
        RECT 0.880 0.760 1.050 1.180 ;
        RECT 0.780 0.410 1.130 0.760 ;
    END
  END Y
  PIN VPWR
    DIRECTION INOUT ;
    USE POWER ;
    PORT
      LAYER nwell ;
        RECT -0.200 1.140 1.570 3.040 ;
      LAYER li1 ;
        RECT -0.200 2.580 1.430 2.900 ;
        RECT 0.180 2.330 0.350 2.580 ;
        RECT 0.100 1.970 0.440 2.330 ;
      LAYER mcon ;
        RECT 0.230 2.640 0.400 2.810 ;
        RECT 1.000 2.650 1.170 2.820 ;
      LAYER met1 ;
        RECT -0.200 2.480 1.570 2.960 ;
    END
  END VPWR
  PIN VGND
    DIRECTION INOUT ;
    USE GROUND ;
    PORT
      LAYER li1 ;
        RECT 0.100 0.410 0.450 0.760 ;
        RECT 0.150 0.210 0.380 0.410 ;
        RECT 0.000 -0.150 1.460 0.210 ;
      LAYER mcon ;
        RECT 0.210 -0.090 0.380 0.080 ;
        RECT 1.050 -0.090 1.220 0.080 ;
      LAYER met1 ;
        RECT -0.110 -0.240 1.570 0.240 ;
    END
  END VGND
 
## Clock tree synthesis
 
 The goal of creating a clock tree is to ensure that the clock input reaches every element and that the clock skew is zero. The H-tree approach is frequently used in CTS. If the slack was attempted to be decreased in a prior run, the netlist may have been altered via cell replacement procedures before performing a CTS run in the TritonCTS tool. As a result, the write_verilog command must be used to modify the verilog file. The synthesis, floorplan, and placement are then run once more. Use the command below to launch CTS:
 run_cts
 The CTS run adds clock buffers in therefore buffer delays come into picture and our analysis from here on deals with real clocks. Setup and hold time slacks may now be analysed in the post-CTS STA anlysis in OpenROAD within the openLANE flow:
 
 openroad
write_db pico_cts.db
read_db pico_cts.db
read_verilog /openLANE_flow/designs/picorv32a/runs/03-07_11-25/results/synthesis/picorv32a.synthesis_cts.v
read_liberty $::env(LIB_SYNTH_COMPLETE)
link_design picorv32a
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc
set_propagated_clock (all_clocks)
report_checks -path_delay min_max -format full_clock_expanded -digits 4
 
Slack 
 
  ![185791682-94f98a0a-56ce-4409-9a66-796675ac5d39](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/0ca4cd1b-5b82-40b6-8ddd-bd7a9680a26e)

 
 ## RTL to GDS
 
 Power Distribution Network generation
Unlike the general ASIC flow, Power Distribution Network generation is not a part of floorplan run in OpenLANE. PDN must be generated after CTS and post-CTS STA analyses:

gen_pdn
We can confirm the success of PDN by checking the current def environment variable: echo $::env(CURRENT_DEF)
 
 
 ![185791987-6a53d110-667f-4243-a27f-056ed20e0154](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/bff36570-dc2a-4baa-a787-a5858c3ade16)

 
1. gen_pdn - Generates the Power Distribution network
2. The power distribution network has to take the design_cts.def as the input def file.
3. This will create the grid and the straps for the Vdd and the ground. These are placed around the standard cells.
4. The standard cells are designed such that it's height is multiples of the space between the Vdd and the ground rails. Here, the pitch is 2.72. Only if the above conditions are adhered it is possible to power the standard cells.
5. The power to the chip, enters through the power pads. There is each for Vdd and Gnd
6. From the pads, the power enters the rings, through the via
7. The straps are connected to the ring. Vdd straps are connected to the Vdd ring and the Gnd Straps are connected to the Gnd ring. There are horizontal and the vertical straps
8. Now the power has to be supplied from the straps to the standard cells. The straps are connected to the rails of the standard cells
9. If macros are present then the straps attach to the rings of the macros via the macro pads and the pdn for the macro is pre-done.
10. There are definitions for the straps and the railss. In this design straps are at metal layer 4 and 5 and the standard cell rails are at the metal layer 1. Vias connect accross the layers as required.
 
## Routing
 
OpenLANE uses the TritonRoute tool for routing. There are 2 stages of routing:

1. Global routing: Routing region is divided into rectangle grids which are represented as course 3D routes (Fastroute tool).
2.  Detailed routing: Finer grids and routing guides used to implement physical wiring (TritonRoute tool).
 
Features of TritonRoute:

Honouring pre-processed route guides
Assumes that each net satisfies inter guide connectivity
Uses MILP based panel routing scheme
Intra-layer parallel and inter-layer sequential routing framework
Running routing step in TritonRoute as part of openLANE flow:

run_routing
run_routing - To start the routing
The options for routing can be set in the config.tcl file.
The optimisations in routing can also be done by specifying the routing strategy to use different version of TritonRoute Engine. There is a trade0ff between the optimised route and the runtime for routing.
For the default setting picorv32a takes approximately 30 minutesaccording to the current version of TritonRoute.
This routing stage must have the CURRENT_DEF set to pdn.def
The two stages of routing are performed by the following engines:
Global Route : Fast Route
Detailed Route : Triton Route
Fast Route generates the routing guides, whereas Triton Route uses the Global Route and then completes the routing with some strategies and optimisations for finding the best possible path connect the pins.
 
##GDSII
 
 GDS Stands for Graphic Design Standard. This is the file that is sent to the foundry and is called as "tape-out".

Fact- Earlier, the GDS files were written on magnetic tapes and sent out to the foundry and hence the name "tape-out"

In openLane use the command magic

The GDSII file is generated in the results/signoff/magic directory.

No DRC errors are found.

The layout pictures are shown below:
 
 ![185795420-9af80389-7205-4a18-ac1b-0f95bd0f9d5c](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/3a3d8a87-2479-4a46-abe3-9ce0c34b8124)

 
 ![185795427-f2a5b5c1-00ef-4c39-aaf5-81e04eb9cb50](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/f6a828d3-6805-4ab7-bd40-278d6acd7392)
 
## LEF
picorv32a.lef.mag file generated is shown below:
 
 
 ![185795429-6fbb2ed0-e787-46d0-a4f7-198ae3bd8fd2](https://github.com/Devi-charan-29/Physical-Design-with-OpenLANE-using-Sky130-PDK/assets/95524221/2a99e128-a2f5-47a8-a55e-0d595dfabb83)

 
 For post-routing STA: run_parasitics_sta

## SPEF: Standard Parasitic Extraction Format

1. Multi-corner STA will be done with the extracted SPEF.
2. SPEF extraction and multi-corner STA will be done on all three corners (min, max, typical).
3. The extracted SPEF can be located under runs/[date]/results/routing
4. Timing ECO should be followed to reduce slack to desired level.
 
## Acknowledgements
The OpenROAD Project
Kunal Ghosh - Co-founder of VSD
Nickson Jose - Workshop Instructor
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 






